import chalk from 'chalk';
import figlet from 'figlet';
import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';
import { prepareDfx } from './components/dfxProject';
import { readCoreFile } from './components/coreInfo';
import { readAppsFile } from './components/appsInfo';
import { BuildService } from './services/buildService';
import { DeployService } from './services/deployService';
import { createUser, UsersManagment } from './components/users/manageUsers';

import * as dotenv from 'dotenv';
import { PocketIcCoreService } from './services/pocketIcCoreService';
import { genFactoryIdl } from './services/genFactoryIdl';
import { FactoryService } from './services/factoryService';

import { URL } from 'url';

dotenv.config();

// Debug information to find genesis of path issues
console.log('=== DEBUG INFO ===');
console.log('Current working directory:', process.cwd());
// eslint-disable-next-line no-undef
console.log('__dirname:', typeof __dirname !== 'undefined' ? __dirname : 'undefined');
// eslint-disable-next-line no-undef
console.log('__filename:', typeof __filename !== 'undefined' ? __filename : 'undefined');
console.log('Process argv:', process.argv);
console.log('==================');

type Command = 'deploy' | 'build' | 'create-user' | 'gen-factory-idl' | 'authorize';

var commandHandled: Command | undefined = undefined;

//Список команд
// eslint-disable-next-line @typescript-eslint/no-explicit-any
let commandArgs: any = {};

// Common options for build and deploy commands
const getCommonBuildAndDeployOptions = (y: ReturnType<typeof yargs>): ReturnType<typeof yargs> => {
  return y
    .option('core', {
      alias: 'c',
      description: 'set core.json file',
      type: 'string',
    })
    .option('apps', {
      alias: 'a',
      description: 'set apps.json file',
      type: 'string',
    });
};

//Main command parser
yargs(hideBin(process.argv))
  .command(
    'deploy',
    'Builds and reinstalls all canisters if there was changes in the code or canister is not running',
    y => {
      y.option('pocket-server', {
        alias: 'pics',
        description:
          'set pocket core server url (else $POCKET_IC_CORE_URL environment variable will be used)',
        type: 'string',
      })
        .option('pic-gateway', {
          alias: 'picgw',
          description:
            'set pic gateway url for agent to work with factory (else $PIC_GATEWAY_URL environment variable will be used)',
          type: 'string',
        })
        .option('skip-build', {
          alias: 'skipb',
          description: 'Skips building canisters',
          type: 'boolean',
        })
        .option('skip-core', {
          alias: 'skipc',
          description: 'Skips building core canisters',
          type: 'boolean',
        })
        .option('user', {
          alias: 'u',
          description: 'User (backed by principal) that deploys apps to factory',
          type: 'string',
          demandOption: true,
        });

      // Apply common options
      getCommonBuildAndDeployOptions(y);
    },
    args => {
      commandHandled = 'deploy';
      commandArgs = args;
    }
  )
  .command(
    'build',
    'Builds all canisters',
    y => {
      // Apply common options
      getCommonBuildAndDeployOptions(y);
    },
    args => {
      commandHandled = 'build';
      commandArgs = args;
    }
  )
  .command(
    'gen-factory-idl',
    'Generate recent factory idl',
    () => {},
    args => {
      commandHandled = 'gen-factory-idl';
      commandArgs = args;
    }
  )
  .command(
    'create-user',
    'Creates a new user',
    y => {
      y.option('name', {
        alias: 'n',
        description: 'create user with this name (stored in the users.json file)',
        type: 'string',
        demandOption: true,
      })
        .option('private-key', {
          alias: 'pk',
          description:
            'create user with this private key. If it is not provided will be autogenerated',
          type: 'string',
        })
        .option('replace', {
          alias: 'r',
          description: 'replace user with this pseudonym if it already exists',
          type: 'boolean',
        });
    },
    args => {
      commandHandled = 'create-user';
      commandArgs = args;
    }
  )
  .command(
    'authorize',
    'Authorizes a user',
    y => {
      y.option('user', {
        alias: 'u',
        description:
          'User (backed by principal) that you want to authorize to deploy apps to factory',
        type: 'string',
        demandOption: true,
      });
    },
    args => {
      commandHandled = 'authorize';
      commandArgs = args;
    }
  )
  .option('dir', {
    alias: 'd',
    description: 'set working directory',
    type: 'string',
  })
  .help()
  .alias('version', 'v')
  .alias('help', 'h')
  .parseSync();

//Показать красивое название тулзы
console.log(chalk.green(figlet.textSync('ICR Cli', { horizontalLayout: 'full' })));

console.log(chalk.bold.whiteBright('Starting ICR (internet computer registry) Cli...'));

const startICRCli = async (): Promise<void> => {
  if (!commandHandled) {
    console.log(chalk.red('No command. See help: icr-cli -h'));
    return;
  }

  const cwd = process.cwd();
  //Если передан параметр dir, то переключаем working directory
  if (commandArgs.dir) {
    process.chdir(commandArgs.dir);
  }

  //First handle users management commands as they do not need dfx.json, core.json and apps.json
  if (commandHandled === 'create-user') {
    const user = commandArgs.name;
    const privateKey = commandArgs['private-key'];
    const replace = commandArgs.replace;

    const usersManager = new UsersManagment('./users.json');

    createUser({ user, privateKey, replace, verbose: true, usersManager });

    return;
  }

  var picCoreUrl: URL | undefined = undefined;
  if (commandHandled === 'deploy' || commandHandled === 'authorize') {
    const pocketIcCoreUrl = commandArgs.pocketServer ?? process.env.POCKET_IC_CORE_URL;
    if (!pocketIcCoreUrl) {
      console.log(
        chalk.red(
          'No pocket server option provided (--pics, --pocket-server flag with url) and no $POCKET_IC_CORE_URL environment variable set'
        )
      );
      return;
    }
    picCoreUrl = new URL(pocketIcCoreUrl);
    if (!picCoreUrl.protocol) {
      console.log(
        chalk.red(
          'Invalid pocket server url (--pics, --pocket-server flag with or $POCKET_IC_CORE_URL environment variable set)'
        )
      );
      return;
    }
  }

  if (commandHandled) {
    try {
      let dfxProjects = prepareDfx();

      if (dfxProjects) {
        let coreInfo = readCoreFile(commandArgs.core);
        if (coreInfo) {
          if (commandHandled === 'gen-factory-idl') {
            const factoryIdl = genFactoryIdl({
              coreInfo,
              dfxProjectsByActorName: dfxProjects,
              projectRoot: cwd,
            });
            console.log(factoryIdl);
            return;
          }

          let appsInfo = readAppsFile(commandArgs.apps);

          //Building for build and deploy commands
          if (commandHandled === 'build' || commandHandled === 'deploy') {
            if (!commandArgs.skipBuild) {
              if (!commandArgs.skipCore) {
                await BuildService.buildCore(coreInfo, dfxProjects);
              }
              if (appsInfo && Object.keys(appsInfo.apps).length > 0) {
                await BuildService.buildApps(appsInfo, dfxProjects);
              }
            }
          }

          //Deploying for deploy command
          let factoryCanisterId: string | undefined = undefined;
          if (commandHandled === 'deploy' && !commandArgs.skipCore) {
            factoryCanisterId = await DeployService.deployCore({
              coreInfo,
              dfxProjectsByActorName: dfxProjects,
              picCoreUrl: picCoreUrl as URL,
            });
          }

          //If we didn't get factory canister id at deployCore step get it directly
          if (!factoryCanisterId) {
            PocketIcCoreService.setPicCoreUrl(picCoreUrl as URL);
            const pocketIcCoreService = PocketIcCoreService.getInstance();
            const cores = await pocketIcCoreService.listCores();
            factoryCanisterId = cores.factory?.canisterIds[0];
          }
          if (!factoryCanisterId) {
            console.log(
              chalk.red('No factory canister id found. Factory canister is not deployed to core!')
            );
            return;
          }

          if (commandHandled === 'deploy' && !(appsInfo && Object.keys(appsInfo.apps).length > 0)) {
            //No apps to deploy
            console.log(chalk.yellow('No apps to deploy (apps.json is empty)'));
            return;
          }

          //Deploying apps to pocket IC
          let picGatewayUrl: URL | undefined = undefined;
          if (commandHandled === 'deploy' || commandHandled === 'authorize') {
            const picGatewayString = commandArgs.picGateway ?? process.env.PIC_GATEWAY_URL;
            if (!picGatewayString) {
              console.log(
                chalk.red(
                  'No pic gateway option provided (--picgw, --pic-gateway flag with url) and no $PIC_GATEWAY_URL environment variable set'
                )
              );
              return;
            }
            picGatewayUrl = new URL(picGatewayString);
            if (!picGatewayUrl.protocol) {
              console.log(
                chalk.red(
                  'Invalid pocket server url (--pics, --pocket-server flag with or $POCKET_IC_CORE_URL environment variable set)'
                )
              );
              return;
            }
          }

          if (commandHandled === 'deploy') {
            if (!picGatewayUrl || !appsInfo) {
              return;
            }

            const usersManager = new UsersManagment('./users.json');
            const user = usersManager.getUser(commandArgs.user);
            if (!user) {
              console.log(chalk.red('User not found'));
              return;
            }

            await DeployService.deployApps({
              appsInfo,
              coreInfo,
              dfxProjectsByActorName: dfxProjects,
              picGatewayUrl: picGatewayUrl,
              factoryCanisterId,
              user,
            });
          }

          if (commandHandled === 'authorize') {
            if (!picGatewayUrl) {
              return;
            }

            const usersManager = new UsersManagment('./users.json');
            const user = usersManager.getUser(commandArgs.user);
            if (!user) {
              console.log(chalk.red('User not found'));
              return;
            }

            console.log('Authorizing user', user.getPrincipal().toString());

            const factoryService = await FactoryService.getInstance(
              picGatewayUrl,
              user,
              factoryCanisterId
            );
            const result = await factoryService.authorize(user.getPrincipal());
            console.log(chalk.green(result));
          }
          return;
        } else {
          console.log(chalk.red('No core.json file found'));
          return;
        }
      } else {
        console.log(chalk.red('No dfx projects found'));
      }
    } catch (e) {
      if (e instanceof Error) {
        console.error('Error: ' + e.message);
      }
      throw e;
    }
  }
  console.log(chalk.green('No command. See help: icr-cli -h'));
};

startICRCli();
